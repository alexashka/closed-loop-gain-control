; Возможно не эффективно используется память, но указателей маловато
;   еще возможно есть лишее копирование данных, лучше то передать указатель
;	так используется память других модулей, с конкр. данными, тогда 
;	не копирования и быстродействие повышается
; Если делать так, то хорошо бы без Public переменных, а доступ делать через методы
;   В них можно проверять корректность данных
;#ifndef _MATH_WRAPPER
constant HERE = 2
#define _MATH_WRAPPER _MATH_WRAPPER
#define THIS _MATH_WRAPPER
#include <../headers/user_modes.inc>
#include <headers/math_wrapper.inc>
extern Vremen
mObject_var	_MATH_WRAPPER
	;/// U_sm corr. unit
	; Property
	iA16_	res		2	; LH	уменьшаемое
	iB16_	res		2	; LH	вычитаемое

object code
; Проц. корр. смещения оптимизированная по скорости
; T oC : 0-127  0!000_0000 -> 0!111_1111 из WREG
; U ue : 0 - (2^16-1) с обрезкой!
; in_arr2_Usm	res	2	; "смещение" LhLl_xhHl - 12 бит
; out_arr2_Usm	res	2	; выходная пара LhLl_xhHl - 12 бит 
; ! происходит семна банка
; public :
mathWr_pub_doTemperCorrectShift; (w, FSR0(+0+1=LH)/ FSR0(+0+1=LH))
	; загрузка уменьшаемого (исходного смещение) в сумматор
	; setMethod()
	movff	POSTINC0, iA16_+0	; L
	movff	POSTINC0, iA16_+1	; H WREG не затрагивает

	; Загружаем данные для преобразования WREG = int8->float32  
	call	_v#v(2)_MATH_SETdw_wByte_to_Aarg	; загрузка
	call	_v#v(2)_MATH_SETdw_FLO32	; преобр.

	; Рассчитать значение поравки в вольтах и перевести  в код
	; 1. Первый множитель коэфф. передачи в код (+4.9*5*1e-3 V/oC),
	;   умножаем на температуру и получаем поравку в вольтах, кот. нужно 
	;   вычесть из подаваемых на транзистор.
	; 2. Переводим эту поравку в 12 разр. код
	;   4095 = 0xFFF -> 1.433 V
	; 3. 1п*2п и загружаем все в B
	; 4. Умножаем не темперетуру
	; 5. Округляем - отбрасываем дробную часть
	; около 70 раз
	mK_to_Barg 	0x85, 0x0C, 0x06, 0x40
	mFPM	; поправка у ue(float32) готова, больше опер. с плав. точкой не будет
	mFloInt	; она же в uint24 

	; Выводим результаты из математического модуля в вычитаемое вычитателя(сумм.)
	;  прям сразу, без локальный переменных
	mObject_sel 	THIS
	lfsr	0, iB16_
	call 	get2LowBytesA_MATH	; выгружаем данные из мат. модуля
	
	; маскируем 0х0F т.к. данные должны быть 12 разрядные 
	mObject_sel 	THIS
	movlw	0x0F
	andwf	iA16_+1	; H 0x0X
	
	; теперь вычитаем A -= B
	; L
	;movf	iB16_+0, w	; пишем в аккамулятор младший байт вычит-ого
	;subwf	iA16_+0			; вычитаем из регистра сод. акк. и пишет в акк.
	; H
	;movf	iB16_+1, w	; пишем в аккамулятор младший байт вычит-ого
	;subwfb	iA16_+1			; вычитаем с учетом заема
	
	; теперь вычитаем A += B
	; L
	movf	iB16_+0, w	; пишем в аккамулятор младший байт вычит-ого
	addwf	iA16_+0			; прибавля сод. акк. без переноса к рег. и пишем обр. в рег
	; H
	movf	iB16_+1, w	; то же, но с переносом
	addwfc	iA16_+1

	; проверка переполнения
	; FF 0F - максимум
	movlw	0xF0
	andwf	iA16_+1,w
	bz		_allRight_
	; если нет переноса, значит был заем, поэтому обнуляемся
	;clrf	iA16_+0	; обнуляем младший байт
	;clrf	iA16_+1	; обнуляем старший байт
	setf	iA16_+0	; ставим на максимум младший байт
	movlw	0x0F
	movff	WREG, iA16_+1
_allRight_:	; все хорошо
	; выводим результаты getMethod()
	lfsr	0, iA16_+0
	return

; Проц. корр. смещения оптимизированная по скорости
; use :
;   warn. : рассчитанное смещение должно быть получено до след. вызова
;     иначе будет стерто 
getCorrUsm_MATH_WRAPPER;(void/FRS0 = +0+1 = LH)
	lfsr	0, iA16_+0
	return
;///

end
#endif




